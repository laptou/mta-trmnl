// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "gtfs-realtime.proto" (package "transit_realtime", syntax proto2)
// tslint:disable
//
// Copyright 2015 The GTFS Specifications Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// Protocol definition file for GTFS Realtime.
//
// GTFS Realtime lets transit agencies provide consumers with realtime
// information about disruptions to their service (stations closed, lines not
// operating, important delays etc), location of their vehicles and expected
// arrival times.
//
// This protocol is published at:
// https://github.com/google/transit/tree/master/gtfs-realtime
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * The contents of a feed message.
 * A feed is a continuous stream of feed messages. Each message in the stream is
 * obtained as a response to an appropriate HTTP GET request.
 * A realtime feed is always defined with relation to an existing GTFS feed.
 * All the entity ids are resolved with respect to the GTFS feed.
 * Note that "required" and "optional" as stated in this file refer to Protocol
 * Buffer cardinality, not semantic cardinality.  See reference.md at
 * https://github.com/google/transit/tree/master/gtfs-realtime for field
 * semantic cardinality.
 *
 * @generated from protobuf message transit_realtime.FeedMessage
 */
export interface FeedMessage {
    /**
     * Metadata about this feed and feed message.
     *
     * @generated from protobuf field: transit_realtime.FeedHeader header = 1;
     */
    header?: FeedHeader;
    /**
     * Contents of the feed.
     *
     * @generated from protobuf field: repeated transit_realtime.FeedEntity entity = 2;
     */
    entity: FeedEntity[];
}
/**
 * Metadata about a feed, included in feed messages.
 *
 * @generated from protobuf message transit_realtime.FeedHeader
 */
export interface FeedHeader {
    /**
     * Version of the feed specification.
     * The current version is 2.0.  Valid versions are "2.0", "1.0".
     *
     * @generated from protobuf field: string gtfs_realtime_version = 1;
     */
    gtfsRealtimeVersion: string;
    /**
     * @generated from protobuf field: optional transit_realtime.FeedHeader.Incrementality incrementality = 2;
     */
    incrementality?: FeedHeader_Incrementality;
    /**
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     *
     * @generated from protobuf field: optional uint64 timestamp = 3;
     */
    timestamp?: bigint;
    /**
     * String that matches the feed_info.feed_version from the GTFS feed that the real
     * time data is based on. Consumers can use this to identify which GTFS feed is
     * currently active or when a new one is available to download.
     *
     * @generated from protobuf field: optional string feed_version = 4;
     */
    feedVersion?: string;
}
/**
 * Determines whether the current fetch is incremental.  Currently,
 * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
 * that use this mode.  There are discussions on the GTFS Realtime mailing
 * list around fully specifying the behavior of DIFFERENTIAL mode and the
 * documentation will be updated when those discussions are finalized.
 *
 * @generated from protobuf enum transit_realtime.FeedHeader.Incrementality
 */
export enum FeedHeader_Incrementality {
    /**
     * @generated from protobuf enum value: FULL_DATASET = 0;
     */
    FULL_DATASET = 0,
    /**
     * @generated from protobuf enum value: DIFFERENTIAL = 1;
     */
    DIFFERENTIAL = 1
}
/**
 * A definition (or update) of an entity in the transit feed.
 *
 * @generated from protobuf message transit_realtime.FeedEntity
 */
export interface FeedEntity {
    /**
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     *
     * @generated from protobuf field: optional bool is_deleted = 2;
     */
    isDeleted?: boolean;
    /**
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     *
     * @generated from protobuf field: optional transit_realtime.TripUpdate trip_update = 3;
     */
    tripUpdate?: TripUpdate;
    /**
     * @generated from protobuf field: optional transit_realtime.VehiclePosition vehicle = 4;
     */
    vehicle?: VehiclePosition;
    /**
     * @generated from protobuf field: optional transit_realtime.Alert alert = 5;
     */
    alert?: Alert;
    /**
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional transit_realtime.Shape shape = 6;
     */
    shape?: Shape;
    /**
     * @generated from protobuf field: optional transit_realtime.Stop stop = 7;
     */
    stop?: Stop;
    /**
     * @generated from protobuf field: optional transit_realtime.TripModifications trip_modifications = 8;
     */
    tripModifications?: TripModifications;
}
// 
// Entities used in the feed.
// 

/**
 * Realtime update of the progress of a vehicle along a trip.
 * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
 * - A trip that proceeds along the schedule.
 * - A trip that proceeds along a route but has no fixed schedule.
 * - A trip that have been added or removed with regard to schedule.
 *
 * The updates can be for future, predicted arrival/departure events, or for
 * past events that already occurred.
 * Normally, updates should get more precise and more certain (see
 * uncertainty below) as the events gets closer to current time.
 * Even if that is not possible, the information for past events should be
 * precise and certain. In particular, if an update points to time in the past
 * but its update's uncertainty is not 0, the client should conclude that the
 * update is a (wrong) prediction and that the trip has not completed yet.
 *
 * Note that the update can describe a trip that is already completed.
 * To this end, it is enough to provide an update for the last stop of the trip.
 * If the time of that is in the past, the client will conclude from that that
 * the whole trip is in the past (it is possible, although inconsequential, to
 * also provide updates for preceding stops).
 * This option is most relevant for a trip that has completed ahead of schedule,
 * but according to the schedule, the trip is still proceeding at the current
 * time. Removing the updates for this trip could make the client assume
 * that the trip is still proceeding.
 * Note that the feed provider is allowed, but not required, to purge past
 * updates - this is one case where this would be practically useful.
 *
 * @generated from protobuf message transit_realtime.TripUpdate
 */
export interface TripUpdate {
    /**
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     *
     * @generated from protobuf field: transit_realtime.TripDescriptor trip = 1;
     */
    trip?: TripDescriptor;
    /**
     * Additional information on the vehicle that is serving this trip.
     *
     * @generated from protobuf field: optional transit_realtime.VehicleDescriptor vehicle = 3;
     */
    vehicle?: VehicleDescriptor;
    /**
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     *
     * @generated from protobuf field: repeated transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
     */
    stopTimeUpdate: TripUpdate_StopTimeUpdate[];
    /**
     * The most recent moment at which the vehicle's real-time progress was measured
     * to estimate StopTimes in the future. When StopTimes in the past are provided,
     * arrival/departure times may be earlier than this value. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     *
     * @generated from protobuf field: optional uint64 timestamp = 4;
     */
    timestamp?: bigint;
    /**
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     *
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     *
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     *
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     *
     * @generated from protobuf field: optional int32 delay = 5;
     */
    delay?: number;
    /**
     * @generated from protobuf field: optional transit_realtime.TripUpdate.TripProperties trip_properties = 6;
     */
    tripProperties?: TripUpdate_TripProperties;
}
/**
 * Timing information for a single predicted event (either arrival or
 * departure).
 * Timing consists of delay and/or estimated time, and uncertainty.
 * - delay should be used when the prediction is given relative to some
 *   existing schedule in GTFS.
 * - time should be given whether there is a predicted schedule or not. If
 *   both time and delay are specified, time will take precedence
 *   (although normally, time, if given for a scheduled trip, should be
 *   equal to scheduled time in GTFS + delay).
 *
 * Uncertainty applies equally to both time and delay.
 * The uncertainty roughly specifies the expected error in true delay (but
 * note, we don't yet define its precise statistical meaning). It's possible
 * for the uncertainty to be 0, for example for trains that are driven under
 * computer timing control.
 *
 * @generated from protobuf message transit_realtime.TripUpdate.StopTimeEvent
 */
export interface TripUpdate_StopTimeEvent {
    /**
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * @generated from protobuf field: optional int32 delay = 1;
     */
    delay?: number;
    /**
     * Event as absolute time.
     * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
     * UTC).
     *
     * @generated from protobuf field: optional int64 time = 2;
     */
    time?: bigint;
    /**
     * If uncertainty is omitted, it is interpreted as unknown.
     * If the prediction is unknown or too uncertain, the delay (or time) field
     * should be empty. In such case, the uncertainty field is ignored.
     * To specify a completely certain prediction, set its uncertainty to 0.
     *
     * @generated from protobuf field: optional int32 uncertainty = 3;
     */
    uncertainty?: number;
}
/**
 * Realtime update for arrival and/or departure events for a given stop on a
 * trip. Updates can be supplied for both past and future events.
 * The producer is allowed, although not required, to drop past events.
 *
 * The update is linked to a specific stop either through stop_sequence or
 * stop_id, so one of the fields below must necessarily be set.
 * See the documentation in TripDescriptor for more information.
 *
 * @generated from protobuf message transit_realtime.TripUpdate.StopTimeUpdate
 */
export interface TripUpdate_StopTimeUpdate {
    /**
     * Must be the same as in stop_times.txt in the corresponding GTFS feed.
     *
     * @generated from protobuf field: optional uint32 stop_sequence = 1;
     */
    stopSequence?: number;
    /**
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     *
     * @generated from protobuf field: optional string stop_id = 4;
     */
    stopId?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
     */
    arrival?: TripUpdate_StopTimeEvent;
    /**
     * @generated from protobuf field: optional transit_realtime.TripUpdate.StopTimeEvent departure = 3;
     */
    departure?: TripUpdate_StopTimeEvent;
    /**
     * Expected occupancy after departure from the given stop.
     * Should be provided only for future stops.
     * In order to provide departure_occupancy_status without either arrival or
     * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA.
     *
     * @generated from protobuf field: optional transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
     */
    departureOccupancyStatus?: VehiclePosition_OccupancyStatus;
    /**
     * @generated from protobuf field: optional transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5;
     */
    scheduleRelationship?: TripUpdate_StopTimeUpdate_ScheduleRelationship;
    /**
     * Realtime updates for certain properties defined within GTFS stop_times.txt
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
     */
    stopTimeProperties?: TripUpdate_StopTimeUpdate_StopTimeProperties;
}
/**
 * Provides the updated values for the stop time.
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf message transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties
 */
export interface TripUpdate_StopTimeUpdate_StopTimeProperties {
    /**
     * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
     * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
     * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
     * "unusual change" if the new stop was presented within an app without any additional context.
     * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
     * same station as the stop originally defined in GTFS stop_times.txt.
     * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
     * StopTimeUpdate.schedule_relationship = NO_DATA.
     * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
     * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
     * Platform assignments should be reflected in other GTFS-realtime fields as well
     * (e.g., `VehiclePosition.stop_id`).
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional string assigned_stop_id = 1;
     */
    assignedStopId?: string;
}
/**
 * The relation between the StopTimeEvents and the static schedule.
 *
 * @generated from protobuf enum transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship
 */
export enum TripUpdate_StopTimeUpdate_ScheduleRelationship {
    /**
     * The vehicle is proceeding in accordance with its static schedule of
     * stops, although not necessarily according to the times of the schedule.
     * At least one of arrival and departure must be provided. If the schedule
     * for this stop contains both arrival and departure times then so must
     * this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
     * should not have a SCHEDULED value and should use UNSCHEDULED instead.
     *
     * @generated from protobuf enum value: SCHEDULED = 0;
     */
    SCHEDULED = 0,
    /**
     * The stop is skipped, i.e., the vehicle will not stop at this stop.
     * Arrival and departure are optional.
     *
     * @generated from protobuf enum value: SKIPPED = 1;
     */
    SKIPPED = 1,
    /**
     * No StopTimeEvents are given for this stop.
     * The main intention for this value is to give time predictions only for
     * part of a trip, i.e., if the last update for a trip has a NO_DATA
     * specifier, then StopTimeEvents for the rest of the stops in the trip
     * are considered to be unspecified as well.
     * Neither arrival nor departure should be supplied.
     *
     * @generated from protobuf enum value: NO_DATA = 2;
     */
    NO_DATA = 2,
    /**
     * The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
     * This value should not be used for trips that are not defined in GTFS frequencies.txt,
     * or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
     * with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     *
     * @generated from protobuf enum value: UNSCHEDULED = 3;
     */
    UNSCHEDULED = 3
}
/**
 * Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
 * trip_id, start_date, and start_time of a DUPLICATED trip.
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf message transit_realtime.TripUpdate.TripProperties
 */
export interface TripUpdate_TripProperties {
    /**
     * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
     * but will start at a different service date and/or time (defined using the TripProperties.start_date and
     * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
     * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
     * be populated and will be ignored by consumers.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional string trip_id = 1;
     */
    tripId?: string;
    /**
     * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
     * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional string start_date = 2;
     */
    startDate?: string;
    /**
     * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
     * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
     * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
     * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
     * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
     * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
     * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
     * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
     * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
     * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
     * populated and will be ignored by consumers.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional string start_time = 3;
     */
    startTime?: string;
    /**
     * Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
     * (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
     * paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
     * nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
     * or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
     * (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
     * be marked as schedule_relationship=SKIPPED.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional string shape_id = 4;
     */
    shapeId?: string;
}
/**
 * Realtime positioning information for a given vehicle.
 *
 * @generated from protobuf message transit_realtime.VehiclePosition
 */
export interface VehiclePosition {
    /**
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     *
     * @generated from protobuf field: optional transit_realtime.TripDescriptor trip = 1;
     */
    trip?: TripDescriptor;
    /**
     * Additional information on the vehicle that is serving this trip.
     *
     * @generated from protobuf field: optional transit_realtime.VehicleDescriptor vehicle = 8;
     */
    vehicle?: VehicleDescriptor;
    /**
     * Current position of this vehicle.
     *
     * @generated from protobuf field: optional transit_realtime.Position position = 2;
     */
    position?: Position;
    /**
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     *
     * @generated from protobuf field: optional uint32 current_stop_sequence = 3;
     */
    currentStopSequence?: number;
    /**
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     *
     * @generated from protobuf field: optional string stop_id = 7;
     */
    stopId?: string;
    /**
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     *
     * @generated from protobuf field: optional transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4;
     */
    currentStatus?: VehiclePosition_VehicleStopStatus;
    /**
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     *
     * @generated from protobuf field: optional uint64 timestamp = 5;
     */
    timestamp?: bigint;
    /**
     * @generated from protobuf field: optional transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
     */
    congestionLevel?: VehiclePosition_CongestionLevel;
    /**
     * If multi_carriage_status is populated with per-carriage OccupancyStatus,
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     *
     * @generated from protobuf field: optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
     */
    occupancyStatus?: VehiclePosition_OccupancyStatus;
    /**
     * A percentage value indicating the degree of passenger occupancy in the vehicle.
     * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
     * The value 100 should represent the total maximum occupancy the vehicle was designed for,
     * including both seated and standing capacity, and current operating regulations allow.
     * The value may exceed 100 if there are more passengers than the maximum designed capacity.
     * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
     * If multi_carriage_status is populated with per-carriage occupancy_percentage,
     * then this field should describe the entire vehicle with all carriages accepting passengers considered.
     * This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional uint32 occupancy_percentage = 10;
     */
    occupancyPercentage?: number;
    /**
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle,
     * given the current direction of travel.
     * The number of occurrences of the multi_carriage_details
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages,
     * like engines, maintenance carriages, etc… as they provide valuable
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: repeated transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
     */
    multiCarriageDetails: VehiclePosition_CarriageDetails[];
}
/**
 * Carriage specific details, used for vehicles composed of several carriages
 * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf message transit_realtime.VehiclePosition.CarriageDetails
 */
export interface VehiclePosition_CarriageDetails {
    /**
     * Identification of the carriage. Should be unique per vehicle.
     *
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * User visible label that may be shown to the passenger to help identify
     * the carriage. Example: "7712", "Car ABC-32", etc...
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional string label = 2;
     */
    label?: string;
    /**
     * Occupancy status for this given carriage, in this vehicle
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3;
     */
    occupancyStatus?: VehiclePosition_OccupancyStatus;
    /**
     * Occupancy percentage for this given carriage, in this vehicle.
     * Follows the same rules as "VehiclePosition.occupancy_percentage"
     * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional int32 occupancy_percentage = 4;
     */
    occupancyPercentage?: number;
    /**
     * Identifies the order of this carriage with respect to the other
     * carriages in the vehicle's list of CarriageDetails.
     * The first carriage in the direction of travel must have a value of 1.
     * The second value corresponds to the second carriage in the direction
     * of travel and must have a value of 2, and so forth.
     * For example, the first carriage in the direction of travel has a value of 1.
     * If the second carriage in the direction of travel has a value of 3,
     * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
     * Carriages without data must be represented with a valid carriage_sequence number and the fields
     * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
     * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional uint32 carriage_sequence = 5;
     */
    carriageSequence?: number;
}
/**
 * @generated from protobuf enum transit_realtime.VehiclePosition.VehicleStopStatus
 */
export enum VehiclePosition_VehicleStopStatus {
    /**
     * The vehicle is just about to arrive at the stop (on a stop
     * display, the vehicle symbol typically flashes).
     *
     * @generated from protobuf enum value: INCOMING_AT = 0;
     */
    INCOMING_AT = 0,
    /**
     * The vehicle is standing at the stop.
     *
     * @generated from protobuf enum value: STOPPED_AT = 1;
     */
    STOPPED_AT = 1,
    /**
     * The vehicle has departed and is in transit to the next stop.
     *
     * @generated from protobuf enum value: IN_TRANSIT_TO = 2;
     */
    IN_TRANSIT_TO = 2
}
/**
 * Congestion level that is affecting this vehicle.
 *
 * @generated from protobuf enum transit_realtime.VehiclePosition.CongestionLevel
 */
export enum VehiclePosition_CongestionLevel {
    /**
     * @generated from protobuf enum value: UNKNOWN_CONGESTION_LEVEL = 0;
     */
    UNKNOWN_CONGESTION_LEVEL = 0,
    /**
     * @generated from protobuf enum value: RUNNING_SMOOTHLY = 1;
     */
    RUNNING_SMOOTHLY = 1,
    /**
     * @generated from protobuf enum value: STOP_AND_GO = 2;
     */
    STOP_AND_GO = 2,
    /**
     * @generated from protobuf enum value: CONGESTION = 3;
     */
    CONGESTION = 3,
    /**
     * People leaving their cars.
     *
     * @generated from protobuf enum value: SEVERE_CONGESTION = 4;
     */
    SEVERE_CONGESTION = 4
}
/**
 * The state of passenger occupancy for the vehicle or carriage.
 * Individual producers may not publish all OccupancyStatus values. Therefore, consumers
 * must not assume that the OccupancyStatus values follow a linear scale.
 * Consumers should represent OccupancyStatus values as the state indicated
 * and intended by the producer. Likewise, producers must use OccupancyStatus values that
 * correspond to actual vehicle occupancy states.
 * For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
 * This field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf enum transit_realtime.VehiclePosition.OccupancyStatus
 */
export enum VehiclePosition_OccupancyStatus {
    /**
     * The vehicle or carriage is considered empty by most measures, and has few or no
     * passengers onboard, but is still accepting passengers.
     *
     * @generated from protobuf enum value: EMPTY = 0;
     */
    EMPTY = 0,
    /**
     * The vehicle or carriage has a large number of seats available.
     * The amount of free seats out of the total seats available to be
     * considered large enough to fall into this category is determined at the
     * discretion of the producer.
     *
     * @generated from protobuf enum value: MANY_SEATS_AVAILABLE = 1;
     */
    MANY_SEATS_AVAILABLE = 1,
    /**
     * The vehicle or carriage has a relatively small number of seats available.
     * The amount of free seats out of the total seats available to be
     * considered small enough to fall into this category is determined at the
     * discretion of the feed producer.
     *
     * @generated from protobuf enum value: FEW_SEATS_AVAILABLE = 2;
     */
    FEW_SEATS_AVAILABLE = 2,
    /**
     * The vehicle or carriage can currently accommodate only standing passengers.
     *
     * @generated from protobuf enum value: STANDING_ROOM_ONLY = 3;
     */
    STANDING_ROOM_ONLY = 3,
    /**
     * The vehicle or carriage can currently accommodate only standing passengers
     * and has limited space for them.
     *
     * @generated from protobuf enum value: CRUSHED_STANDING_ROOM_ONLY = 4;
     */
    CRUSHED_STANDING_ROOM_ONLY = 4,
    /**
     * The vehicle or carriage is considered full by most measures, but may still be
     * allowing passengers to board.
     *
     * @generated from protobuf enum value: FULL = 5;
     */
    FULL = 5,
    /**
     * The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
     *
     * @generated from protobuf enum value: NOT_ACCEPTING_PASSENGERS = 6;
     */
    NOT_ACCEPTING_PASSENGERS = 6,
    /**
     * The vehicle or carriage doesn't have any occupancy data available at that time.
     *
     * @generated from protobuf enum value: NO_DATA_AVAILABLE = 7;
     */
    NO_DATA_AVAILABLE = 7,
    /**
     * The vehicle or carriage is not boardable and never accepts passengers.
     * Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
     *
     * @generated from protobuf enum value: NOT_BOARDABLE = 8;
     */
    NOT_BOARDABLE = 8
}
/**
 * An alert, indicating some sort of incident in the public transit network.
 *
 * @generated from protobuf message transit_realtime.Alert
 */
export interface Alert {
    /**
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     *
     * @generated from protobuf field: repeated transit_realtime.TimeRange active_period = 1;
     */
    activePeriod: TimeRange[];
    /**
     * Entities whose users we should notify of this alert.
     *
     * @generated from protobuf field: repeated transit_realtime.EntitySelector informed_entity = 5;
     */
    informedEntity: EntitySelector[];
    /**
     * @generated from protobuf field: optional transit_realtime.Alert.Cause cause = 6;
     */
    cause?: Alert_Cause;
    /**
     * @generated from protobuf field: optional transit_realtime.Alert.Effect effect = 7;
     */
    effect?: Alert_Effect;
    /**
     * The URL which provides additional information about the alert.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString url = 8;
     */
    url?: TranslatedString;
    /**
     * Alert header. Contains a short summary of the alert text as plain-text.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString header_text = 10;
     */
    headerText?: TranslatedString;
    /**
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString description_text = 11;
     */
    descriptionText?: TranslatedString;
    /**
     * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString tts_header_text = 12;
     */
    ttsHeaderText?: TranslatedString;
    /**
     * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString tts_description_text = 13;
     */
    ttsDescriptionText?: TranslatedString;
    /**
     * @generated from protobuf field: optional transit_realtime.Alert.SeverityLevel severity_level = 14;
     */
    severityLevel?: Alert_SeverityLevel;
    /**
     * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
     * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedImage image = 15;
     */
    image?: TranslatedImage;
    /**
     * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
     * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString image_alternative_text = 16;
     */
    imageAlternativeText?: TranslatedString;
    /**
     * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString cause_detail = 17;
     */
    causeDetail?: TranslatedString;
    /**
     * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional transit_realtime.TranslatedString effect_detail = 18;
     */
    effectDetail?: TranslatedString;
}
/**
 * Cause of this alert. If cause_detail is included, then Cause must also be included.
 *
 * @generated from protobuf enum transit_realtime.Alert.Cause
 */
export enum Alert_Cause {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: UNKNOWN_CAUSE = 1;
     */
    UNKNOWN_CAUSE = 1,
    /**
     * Not machine-representable.
     *
     * @generated from protobuf enum value: OTHER_CAUSE = 2;
     */
    OTHER_CAUSE = 2,
    /**
     * @generated from protobuf enum value: TECHNICAL_PROBLEM = 3;
     */
    TECHNICAL_PROBLEM = 3,
    /**
     * Public transit agency employees stopped working.
     *
     * @generated from protobuf enum value: STRIKE = 4;
     */
    STRIKE = 4,
    /**
     * People are blocking the streets.
     *
     * @generated from protobuf enum value: DEMONSTRATION = 5;
     */
    DEMONSTRATION = 5,
    /**
     * @generated from protobuf enum value: ACCIDENT = 6;
     */
    ACCIDENT = 6,
    /**
     * @generated from protobuf enum value: HOLIDAY = 7;
     */
    HOLIDAY = 7,
    /**
     * @generated from protobuf enum value: WEATHER = 8;
     */
    WEATHER = 8,
    /**
     * @generated from protobuf enum value: MAINTENANCE = 9;
     */
    MAINTENANCE = 9,
    /**
     * @generated from protobuf enum value: CONSTRUCTION = 10;
     */
    CONSTRUCTION = 10,
    /**
     * @generated from protobuf enum value: POLICE_ACTIVITY = 11;
     */
    POLICE_ACTIVITY = 11,
    /**
     * @generated from protobuf enum value: MEDICAL_EMERGENCY = 12;
     */
    MEDICAL_EMERGENCY = 12
}
/**
 * What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included.
 *
 * @generated from protobuf enum transit_realtime.Alert.Effect
 */
export enum Alert_Effect {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: NO_SERVICE = 1;
     */
    NO_SERVICE = 1,
    /**
     * @generated from protobuf enum value: REDUCED_SERVICE = 2;
     */
    REDUCED_SERVICE = 2,
    /**
     * We don't care about INsignificant delays: they are hard to detect, have
     * little impact on the user, and would clutter the results as they are too
     * frequent.
     *
     * @generated from protobuf enum value: SIGNIFICANT_DELAYS = 3;
     */
    SIGNIFICANT_DELAYS = 3,
    /**
     * @generated from protobuf enum value: DETOUR = 4;
     */
    DETOUR = 4,
    /**
     * @generated from protobuf enum value: ADDITIONAL_SERVICE = 5;
     */
    ADDITIONAL_SERVICE = 5,
    /**
     * @generated from protobuf enum value: MODIFIED_SERVICE = 6;
     */
    MODIFIED_SERVICE = 6,
    /**
     * @generated from protobuf enum value: OTHER_EFFECT = 7;
     */
    OTHER_EFFECT = 7,
    /**
     * @generated from protobuf enum value: UNKNOWN_EFFECT = 8;
     */
    UNKNOWN_EFFECT = 8,
    /**
     * @generated from protobuf enum value: STOP_MOVED = 9;
     */
    STOP_MOVED = 9,
    /**
     * @generated from protobuf enum value: NO_EFFECT = 10;
     */
    NO_EFFECT = 10,
    /**
     * @generated from protobuf enum value: ACCESSIBILITY_ISSUE = 11;
     */
    ACCESSIBILITY_ISSUE = 11
}
/**
 * Severity of this alert.
 *
 * @generated from protobuf enum transit_realtime.Alert.SeverityLevel
 */
export enum Alert_SeverityLevel {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: UNKNOWN_SEVERITY = 1;
     */
    UNKNOWN_SEVERITY = 1,
    /**
     * @generated from protobuf enum value: INFO = 2;
     */
    INFO = 2,
    /**
     * @generated from protobuf enum value: WARNING = 3;
     */
    WARNING = 3,
    /**
     * @generated from protobuf enum value: SEVERE = 4;
     */
    SEVERE = 4
}
// 
// Low level data structures used above.
// 

/**
 * A time interval. The interval is considered active at time 't' if 't' is
 * greater than or equal to the start time and less than the end time.
 *
 * @generated from protobuf message transit_realtime.TimeRange
 */
export interface TimeRange {
    /**
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     *
     * @generated from protobuf field: optional uint64 start = 1;
     */
    start?: bigint;
    /**
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     *
     * @generated from protobuf field: optional uint64 end = 2;
     */
    end?: bigint;
}
/**
 * A position.
 *
 * @generated from protobuf message transit_realtime.Position
 */
export interface Position {
    /**
     * Degrees North, in the WGS-84 coordinate system.
     *
     * @generated from protobuf field: float latitude = 1;
     */
    latitude: number;
    /**
     * Degrees East, in the WGS-84 coordinate system.
     *
     * @generated from protobuf field: float longitude = 2;
     */
    longitude: number;
    /**
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     *
     * @generated from protobuf field: optional float bearing = 3;
     */
    bearing?: number;
    /**
     * Odometer value, in meters.
     *
     * @generated from protobuf field: optional double odometer = 4;
     */
    odometer?: number;
    /**
     * Momentary speed measured by the vehicle, in meters per second.
     *
     * @generated from protobuf field: optional float speed = 5;
     */
    speed?: number;
}
/**
 * A descriptor that identifies an instance of a GTFS trip, or all instances of
 * a trip along a route.
 * - To specify a single trip instance, the trip_id (and if necessary,
 *   start_time) is set. If route_id is also set, then it should be same as one
 *   that the given trip corresponds to.
 * - To specify all the trips along a given route, only the route_id should be
 *   set. Note that if the trip_id is not known, then stop sequence ids in
 *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
 *   addition, absolute arrival/departure times must be provided.
 *
 * @generated from protobuf message transit_realtime.TripDescriptor
 */
export interface TripDescriptor {
    /**
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
     * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
     * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
     *
     * @generated from protobuf field: optional string trip_id = 1;
     */
    tripId?: string;
    /**
     * The route_id from the GTFS that this selector refers to.
     *
     * @generated from protobuf field: optional string route_id = 5;
     */
    routeId?: string;
    /**
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to.
     *
     * @generated from protobuf field: optional uint32 direction_id = 6;
     */
    directionId?: number;
    /**
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     *
     * @generated from protobuf field: optional string start_time = 2;
     */
    startTime?: string;
    /**
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     *
     * @generated from protobuf field: optional string start_date = 3;
     */
    startDate?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
     */
    scheduleRelationship?: TripDescriptor_ScheduleRelationship;
    /**
     * Linkage to any modifications done to this trip (shape changes, removal or addition of stops).
     * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value.
     *
     * @generated from protobuf field: optional transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;
     */
    modifiedTrip?: TripDescriptor_ModifiedTripSelector;
}
/**
 * @generated from protobuf message transit_realtime.TripDescriptor.ModifiedTripSelector
 */
export interface TripDescriptor_ModifiedTripSelector {
    /**
     * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
     *
     * @generated from protobuf field: optional string modifications_id = 1;
     */
    modificationsId?: string;
    /**
     * The trip_id from the GTFS feed that is modified by the modifications_id
     *
     * @generated from protobuf field: optional string affected_trip_id = 2;
     */
    affectedTripId?: string;
    /**
     * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
     *
     * @generated from protobuf field: optional string start_time = 3;
     */
    startTime?: string;
    /**
     * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
     *
     * @generated from protobuf field: optional string start_date = 4;
     */
    startDate?: string;
}
/**
 * The relation between this trip and the static schedule. If a trip is done
 * in accordance with temporary schedule, not reflected in GTFS, then it
 * shouldn't be marked as SCHEDULED, but likely as ADDED.
 *
 * @generated from protobuf enum transit_realtime.TripDescriptor.ScheduleRelationship
 */
export enum TripDescriptor_ScheduleRelationship {
    /**
     * Trip that is running in accordance with its GTFS schedule, or is close
     * enough to the scheduled trip to be associated with it.
     *
     * @generated from protobuf enum value: SCHEDULED = 0;
     */
    SCHEDULED = 0,
    /**
     * An extra trip that was added in addition to a running schedule, for
     * example, to replace a broken vehicle or to respond to sudden passenger
     * load.
     * NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub
     * [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221)
     * [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the
     * documentation will be updated when those discussions are finalized.
     *
     * @generated from protobuf enum value: ADDED = 1;
     */
    ADDED = 1,
    /**
     * A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
     * Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
     *
     * @generated from protobuf enum value: UNSCHEDULED = 2;
     */
    UNSCHEDULED = 2,
    /**
     * A trip that existed in the schedule but was removed.
     *
     * @generated from protobuf enum value: CANCELED = 3;
     */
    CANCELED = 3,
    /**
     * Should not be used - for backwards-compatibility only.
     *
     * @deprecated
     * @generated from protobuf enum value: REPLACEMENT = 5 [deprecated = true];
     */
    REPLACEMENT = 5,
    /**
     * An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
     * respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
     * and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
     * date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
     * (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
     * identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
     * TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
     * TripUpdate with the value of CANCELED or DELETED. Trips defined in GTFS frequencies.txt with exact_times that is
     * empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
     * the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
     * must also be set to DUPLICATED.
     * Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
     * the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
     * to transition to the DUPLICATED enumeration.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf enum value: DUPLICATED = 6;
     */
    DUPLICATED = 6,
    /**
     * A trip that existed in the schedule but was removed and must not be shown to users.
     * DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
     * information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
     * riders, e.g. a trip that is entirely being replaced by another trip.
     * This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
     * If consumers were to show explicit information about the cancellations it would distract from the more important
     * real-time predictions.
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf enum value: DELETED = 7;
     */
    DELETED = 7
}
/**
 * Identification information for the vehicle performing the trip.
 *
 * @generated from protobuf message transit_realtime.VehicleDescriptor
 */
export interface VehicleDescriptor {
    /**
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     *
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     *
     * @generated from protobuf field: optional string label = 2;
     */
    label?: string;
    /**
     * The license plate of the vehicle.
     *
     * @generated from protobuf field: optional string license_plate = 3;
     */
    licensePlate?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4;
     */
    wheelchairAccessible?: VehicleDescriptor_WheelchairAccessible;
}
/**
 * @generated from protobuf enum transit_realtime.VehicleDescriptor.WheelchairAccessible
 */
export enum VehicleDescriptor_WheelchairAccessible {
    /**
     * The trip doesn't have information about wheelchair accessibility.
     * This is the **default** behavior. If the static GTFS contains a
     * _wheelchair_accessible_ value, it won't be overwritten.
     *
     * @generated from protobuf enum value: NO_VALUE = 0;
     */
    NO_VALUE = 0,
    /**
     * The trip has no accessibility value present.
     * This value will overwrite the value from the GTFS.
     *
     * @generated from protobuf enum value: UNKNOWN = 1;
     */
    UNKNOWN = 1,
    /**
     * The trip is wheelchair accessible.
     * This value will overwrite the value from the GTFS.
     *
     * @generated from protobuf enum value: WHEELCHAIR_ACCESSIBLE = 2;
     */
    WHEELCHAIR_ACCESSIBLE = 2,
    /**
     * The trip is **not** wheelchair accessible.
     * This value will overwrite the value from the GTFS.
     *
     * @generated from protobuf enum value: WHEELCHAIR_INACCESSIBLE = 3;
     */
    WHEELCHAIR_INACCESSIBLE = 3
}
/**
 * A selector for an entity in a GTFS feed.
 *
 * @generated from protobuf message transit_realtime.EntitySelector
 */
export interface EntitySelector {
    /**
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     *
     * @generated from protobuf field: optional string agency_id = 1;
     */
    agencyId?: string;
    /**
     * @generated from protobuf field: optional string route_id = 2;
     */
    routeId?: string;
    /**
     * corresponds to route_type in GTFS.
     *
     * @generated from protobuf field: optional int32 route_type = 3;
     */
    routeType?: number;
    /**
     * @generated from protobuf field: optional transit_realtime.TripDescriptor trip = 4;
     */
    trip?: TripDescriptor;
    /**
     * @generated from protobuf field: optional string stop_id = 5;
     */
    stopId?: string;
    /**
     * Corresponds to trip direction_id in GTFS trips.txt. If provided the
     * route_id must also be provided.
     *
     * @generated from protobuf field: optional uint32 direction_id = 6;
     */
    directionId?: number;
}
/**
 * An internationalized message containing per-language versions of a snippet of
 * text or a URL.
 * One of the strings from a message will be picked up. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 *
 * @generated from protobuf message transit_realtime.TranslatedString
 */
export interface TranslatedString {
    /**
     * At least one translation must be provided.
     *
     * @generated from protobuf field: repeated transit_realtime.TranslatedString.Translation translation = 1;
     */
    translation: TranslatedString_Translation[];
}
/**
 * @generated from protobuf message transit_realtime.TranslatedString.Translation
 */
export interface TranslatedString_Translation {
    /**
     * A UTF-8 string containing the message.
     *
     * @generated from protobuf field: string text = 1;
     */
    text: string;
    /**
     * BCP-47 language code. Can be omitted if the language is unknown or if
     * no i18n is done at all for the feed. At most one translation is
     * allowed to have an unspecified language tag.
     *
     * @generated from protobuf field: optional string language = 2;
     */
    language?: string;
}
/**
 * An internationalized image containing per-language versions of a URL linking to an image
 * along with meta information
 * Only one of the images from a message will be retained by consumers. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf message transit_realtime.TranslatedImage
 */
export interface TranslatedImage {
    /**
     * At least one localized image must be provided.
     *
     * @generated from protobuf field: repeated transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
     */
    localizedImage: TranslatedImage_LocalizedImage[];
}
/**
 * @generated from protobuf message transit_realtime.TranslatedImage.LocalizedImage
 */
export interface TranslatedImage_LocalizedImage {
    /**
     * String containing an URL linking to an image
     * The image linked must be less than 2MB.
     * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
     * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
     *
     * @generated from protobuf field: string url = 1;
     */
    url: string;
    /**
     * IANA media type as to specify the type of image to be displayed.
     * The type must start with "image/"
     *
     * @generated from protobuf field: string media_type = 2;
     */
    mediaType: string;
    /**
     * BCP-47 language code. Can be omitted if the language is unknown or if
     * no i18n is done at all for the feed. At most one translation is
     * allowed to have an unspecified language tag.
     *
     * @generated from protobuf field: optional string language = 3;
     */
    language?: string;
}
/**
 * Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
 * such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
 * Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
 * the location of Stops exactly, but all Stops on a trip should lie within a small distance of
 * the shape for that trip, i.e. close to straight line segments connecting the shape points
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf message transit_realtime.Shape
 */
export interface Shape {
    /**
     * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional string shape_id = 1;
     */
    shapeId?: string;
    /**
     * Encoded polyline representation of the shape. This polyline must contain at least two points.
     * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
     * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
     * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
     * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
     *
     * @generated from protobuf field: optional string encoded_polyline = 2;
     */
    encodedPolyline?: string;
}
/**
 * Describes a stop which is served by trips. All fields are as described in the GTFS-Static specification.
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf message transit_realtime.Stop
 */
export interface Stop {
    /**
     * @generated from protobuf field: optional string stop_id = 1;
     */
    stopId?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.TranslatedString stop_code = 2;
     */
    stopCode?: TranslatedString;
    /**
     * @generated from protobuf field: optional transit_realtime.TranslatedString stop_name = 3;
     */
    stopName?: TranslatedString;
    /**
     * @generated from protobuf field: optional transit_realtime.TranslatedString tts_stop_name = 4;
     */
    ttsStopName?: TranslatedString;
    /**
     * @generated from protobuf field: optional transit_realtime.TranslatedString stop_desc = 5;
     */
    stopDesc?: TranslatedString;
    /**
     * @generated from protobuf field: optional float stop_lat = 6;
     */
    stopLat?: number;
    /**
     * @generated from protobuf field: optional float stop_lon = 7;
     */
    stopLon?: number;
    /**
     * @generated from protobuf field: optional string zone_id = 8;
     */
    zoneId?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.TranslatedString stop_url = 9;
     */
    stopUrl?: TranslatedString;
    /**
     * @generated from protobuf field: optional string parent_station = 11;
     */
    parentStation?: string;
    /**
     * @generated from protobuf field: optional string stop_timezone = 12;
     */
    stopTimezone?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13;
     */
    wheelchairBoarding?: Stop_WheelchairBoarding;
    /**
     * @generated from protobuf field: optional string level_id = 14;
     */
    levelId?: string;
    /**
     * @generated from protobuf field: optional transit_realtime.TranslatedString platform_code = 15;
     */
    platformCode?: TranslatedString;
}
/**
 * @generated from protobuf enum transit_realtime.Stop.WheelchairBoarding
 */
export enum Stop_WheelchairBoarding {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: AVAILABLE = 1;
     */
    AVAILABLE = 1,
    /**
     * @generated from protobuf enum value: NOT_AVAILABLE = 2;
     */
    NOT_AVAILABLE = 2
}
/**
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf message transit_realtime.TripModifications
 */
export interface TripModifications {
    /**
     * A list of selected trips affected by this TripModifications.
     *
     * @generated from protobuf field: repeated transit_realtime.TripModifications.SelectedTrips selected_trips = 1;
     */
    selectedTrips: TripModifications_SelectedTrips[];
    /**
     * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids.
     * Useful to target multiple departures of a trip_id in a frequency-based trip.
     *
     * @generated from protobuf field: repeated string start_times = 2;
     */
    startTimes: string[];
    /**
     * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
     * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
     *
     * @generated from protobuf field: repeated string service_dates = 3;
     */
    serviceDates: string[];
    /**
     * A list of modifications to apply to the affected trips.
     *
     * @generated from protobuf field: repeated transit_realtime.TripModifications.Modification modifications = 4;
     */
    modifications: TripModifications_Modification[];
}
/**
 * A `Modification` message replaces a span of n stop times from each affected trip starting at `start_stop_selector`.
 *
 * @generated from protobuf message transit_realtime.TripModifications.Modification
 */
export interface TripModifications_Modification {
    /**
     * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
     * Used in conjuction with `end_stop_selector`.
     * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
     *
     * @generated from protobuf field: optional transit_realtime.StopSelector start_stop_selector = 1;
     */
    startStopSelector?: StopSelector;
    /**
     * The stop selector of the last stop of the original trip that is to be affected by this modification.
     * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
     * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
     *
     * @generated from protobuf field: optional transit_realtime.StopSelector end_stop_selector = 2;
     */
    endStopSelector?: StopSelector;
    /**
     * The number of seconds of delay to add to all departure and arrival times following the end of this modification.
     * If multiple modifications apply to the same trip, the delays accumulate as the trip advances.
     *
     * @generated from protobuf field: optional int32 propagated_modification_delay = 3;
     */
    propagatedModificationDelay?: number;
    /**
     * A list of replacement stops, replacing those of the original trip.
     * The length of the new stop times may be less, the same, or greater than the number of replaced stop times.
     *
     * @generated from protobuf field: repeated transit_realtime.ReplacementStop replacement_stops = 4;
     */
    replacementStops: ReplacementStop[];
    /**
     * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
     *
     * @generated from protobuf field: optional string service_alert_id = 5;
     */
    serviceAlertId?: string;
    /**
     * This timestamp identifies the moment when the modification has last been changed.
     * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     *
     * @generated from protobuf field: optional uint64 last_modified_time = 6;
     */
    lastModifiedTime?: bigint;
}
/**
 * @generated from protobuf message transit_realtime.TripModifications.SelectedTrips
 */
export interface TripModifications_SelectedTrips {
    /**
     * A list of trips affected with this replacement that all have the same new `shape_id`.
     *
     * @generated from protobuf field: repeated string trip_ids = 1;
     */
    tripIds: string[];
    /**
     * The ID of the new shape for the modified trips in this SelectedTrips.
     * May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feed’s shapes.txt.
     *
     * @generated from protobuf field: optional string shape_id = 2;
     */
    shapeId?: string;
}
/**
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 * Select a stop by stop sequence or by stop_id. At least one of the two values must be provided.
 *
 * @generated from protobuf message transit_realtime.StopSelector
 */
export interface StopSelector {
    /**
     * Must be the same as in stop_times.txt in the corresponding GTFS feed.
     *
     * @generated from protobuf field: optional uint32 stop_sequence = 1;
     */
    stopSequence?: number;
    /**
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     *
     * @generated from protobuf field: optional string stop_id = 2;
     */
    stopId?: string;
}
/**
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from protobuf message transit_realtime.ReplacementStop
 */
export interface ReplacementStop {
    /**
     * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
     * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
     *
     * @generated from protobuf field: optional int32 travel_time_to_stop = 1;
     */
    travelTimeToStop?: number;
    /**
     * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feed’s stops.txt. The stop MUST have location_type=0 (routable stops).
     *
     * @generated from protobuf field: optional string stop_id = 2;
     */
    stopId?: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class FeedMessage$Type extends MessageType<FeedMessage> {
    constructor() {
        super("transit_realtime.FeedMessage", [
            { no: 1, name: "header", kind: "message", T: () => FeedHeader },
            { no: 2, name: "entity", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FeedEntity }
        ]);
    }
    create(value?: PartialMessage<FeedMessage>): FeedMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entity = [];
        if (value !== undefined)
            reflectionMergePartial<FeedMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedMessage): FeedMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* transit_realtime.FeedHeader header */ 1:
                    message.header = FeedHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated transit_realtime.FeedEntity entity */ 2:
                    message.entity.push(FeedEntity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* transit_realtime.FeedHeader header = 1; */
        if (message.header)
            FeedHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated transit_realtime.FeedEntity entity = 2; */
        for (let i = 0; i < message.entity.length; i++)
            FeedEntity.internalBinaryWrite(message.entity[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.FeedMessage
 */
export const FeedMessage = new FeedMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedHeader$Type extends MessageType<FeedHeader> {
    constructor() {
        super("transit_realtime.FeedHeader", [
            { no: 1, name: "gtfs_realtime_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "incrementality", kind: "enum", opt: true, T: () => ["transit_realtime.FeedHeader.Incrementality", FeedHeader_Incrementality] },
            { no: 3, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "feed_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FeedHeader>): FeedHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gtfsRealtimeVersion = "";
        if (value !== undefined)
            reflectionMergePartial<FeedHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedHeader): FeedHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string gtfs_realtime_version */ 1:
                    message.gtfsRealtimeVersion = reader.string();
                    break;
                case /* optional transit_realtime.FeedHeader.Incrementality incrementality */ 2:
                    message.incrementality = reader.int32();
                    break;
                case /* optional uint64 timestamp */ 3:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional string feed_version */ 4:
                    message.feedVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string gtfs_realtime_version = 1; */
        if (message.gtfsRealtimeVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gtfsRealtimeVersion);
        /* optional transit_realtime.FeedHeader.Incrementality incrementality = 2; */
        if (message.incrementality !== undefined)
            writer.tag(2, WireType.Varint).int32(message.incrementality);
        /* optional uint64 timestamp = 3; */
        if (message.timestamp !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.timestamp);
        /* optional string feed_version = 4; */
        if (message.feedVersion !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.feedVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.FeedHeader
 */
export const FeedHeader = new FeedHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeedEntity$Type extends MessageType<FeedEntity> {
    constructor() {
        super("transit_realtime.FeedEntity", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_deleted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "trip_update", kind: "message", T: () => TripUpdate },
            { no: 4, name: "vehicle", kind: "message", T: () => VehiclePosition },
            { no: 5, name: "alert", kind: "message", T: () => Alert },
            { no: 6, name: "shape", kind: "message", T: () => Shape },
            { no: 7, name: "stop", kind: "message", T: () => Stop },
            { no: 8, name: "trip_modifications", kind: "message", T: () => TripModifications }
        ]);
    }
    create(value?: PartialMessage<FeedEntity>): FeedEntity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<FeedEntity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeedEntity): FeedEntity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional bool is_deleted */ 2:
                    message.isDeleted = reader.bool();
                    break;
                case /* optional transit_realtime.TripUpdate trip_update */ 3:
                    message.tripUpdate = TripUpdate.internalBinaryRead(reader, reader.uint32(), options, message.tripUpdate);
                    break;
                case /* optional transit_realtime.VehiclePosition vehicle */ 4:
                    message.vehicle = VehiclePosition.internalBinaryRead(reader, reader.uint32(), options, message.vehicle);
                    break;
                case /* optional transit_realtime.Alert alert */ 5:
                    message.alert = Alert.internalBinaryRead(reader, reader.uint32(), options, message.alert);
                    break;
                case /* optional transit_realtime.Shape shape */ 6:
                    message.shape = Shape.internalBinaryRead(reader, reader.uint32(), options, message.shape);
                    break;
                case /* optional transit_realtime.Stop stop */ 7:
                    message.stop = Stop.internalBinaryRead(reader, reader.uint32(), options, message.stop);
                    break;
                case /* optional transit_realtime.TripModifications trip_modifications */ 8:
                    message.tripModifications = TripModifications.internalBinaryRead(reader, reader.uint32(), options, message.tripModifications);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeedEntity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional bool is_deleted = 2; */
        if (message.isDeleted !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isDeleted);
        /* optional transit_realtime.TripUpdate trip_update = 3; */
        if (message.tripUpdate)
            TripUpdate.internalBinaryWrite(message.tripUpdate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.VehiclePosition vehicle = 4; */
        if (message.vehicle)
            VehiclePosition.internalBinaryWrite(message.vehicle, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Alert alert = 5; */
        if (message.alert)
            Alert.internalBinaryWrite(message.alert, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Shape shape = 6; */
        if (message.shape)
            Shape.internalBinaryWrite(message.shape, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Stop stop = 7; */
        if (message.stop)
            Stop.internalBinaryWrite(message.stop, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TripModifications trip_modifications = 8; */
        if (message.tripModifications)
            TripModifications.internalBinaryWrite(message.tripModifications, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.FeedEntity
 */
export const FeedEntity = new FeedEntity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripUpdate$Type extends MessageType<TripUpdate> {
    constructor() {
        super("transit_realtime.TripUpdate", [
            { no: 1, name: "trip", kind: "message", T: () => TripDescriptor },
            { no: 3, name: "vehicle", kind: "message", T: () => VehicleDescriptor },
            { no: 2, name: "stop_time_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TripUpdate_StopTimeUpdate },
            { no: 4, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "delay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "trip_properties", kind: "message", T: () => TripUpdate_TripProperties }
        ]);
    }
    create(value?: PartialMessage<TripUpdate>): TripUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stopTimeUpdate = [];
        if (value !== undefined)
            reflectionMergePartial<TripUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripUpdate): TripUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* transit_realtime.TripDescriptor trip */ 1:
                    message.trip = TripDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.trip);
                    break;
                case /* optional transit_realtime.VehicleDescriptor vehicle */ 3:
                    message.vehicle = VehicleDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.vehicle);
                    break;
                case /* repeated transit_realtime.TripUpdate.StopTimeUpdate stop_time_update */ 2:
                    message.stopTimeUpdate.push(TripUpdate_StopTimeUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 timestamp */ 4:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional int32 delay */ 5:
                    message.delay = reader.int32();
                    break;
                case /* optional transit_realtime.TripUpdate.TripProperties trip_properties */ 6:
                    message.tripProperties = TripUpdate_TripProperties.internalBinaryRead(reader, reader.uint32(), options, message.tripProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* transit_realtime.TripDescriptor trip = 1; */
        if (message.trip)
            TripDescriptor.internalBinaryWrite(message.trip, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.VehicleDescriptor vehicle = 3; */
        if (message.vehicle)
            VehicleDescriptor.internalBinaryWrite(message.vehicle, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2; */
        for (let i = 0; i < message.stopTimeUpdate.length; i++)
            TripUpdate_StopTimeUpdate.internalBinaryWrite(message.stopTimeUpdate[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 timestamp = 4; */
        if (message.timestamp !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.timestamp);
        /* optional int32 delay = 5; */
        if (message.delay !== undefined)
            writer.tag(5, WireType.Varint).int32(message.delay);
        /* optional transit_realtime.TripUpdate.TripProperties trip_properties = 6; */
        if (message.tripProperties)
            TripUpdate_TripProperties.internalBinaryWrite(message.tripProperties, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripUpdate
 */
export const TripUpdate = new TripUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripUpdate_StopTimeEvent$Type extends MessageType<TripUpdate_StopTimeEvent> {
    constructor() {
        super("transit_realtime.TripUpdate.StopTimeEvent", [
            { no: 1, name: "delay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "time", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "uncertainty", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TripUpdate_StopTimeEvent>): TripUpdate_StopTimeEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TripUpdate_StopTimeEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripUpdate_StopTimeEvent): TripUpdate_StopTimeEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 delay */ 1:
                    message.delay = reader.int32();
                    break;
                case /* optional int64 time */ 2:
                    message.time = reader.int64().toBigInt();
                    break;
                case /* optional int32 uncertainty */ 3:
                    message.uncertainty = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripUpdate_StopTimeEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 delay = 1; */
        if (message.delay !== undefined)
            writer.tag(1, WireType.Varint).int32(message.delay);
        /* optional int64 time = 2; */
        if (message.time !== undefined)
            writer.tag(2, WireType.Varint).int64(message.time);
        /* optional int32 uncertainty = 3; */
        if (message.uncertainty !== undefined)
            writer.tag(3, WireType.Varint).int32(message.uncertainty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripUpdate.StopTimeEvent
 */
export const TripUpdate_StopTimeEvent = new TripUpdate_StopTimeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripUpdate_StopTimeUpdate$Type extends MessageType<TripUpdate_StopTimeUpdate> {
    constructor() {
        super("transit_realtime.TripUpdate.StopTimeUpdate", [
            { no: 1, name: "stop_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "arrival", kind: "message", T: () => TripUpdate_StopTimeEvent },
            { no: 3, name: "departure", kind: "message", T: () => TripUpdate_StopTimeEvent },
            { no: 7, name: "departure_occupancy_status", kind: "enum", opt: true, T: () => ["transit_realtime.VehiclePosition.OccupancyStatus", VehiclePosition_OccupancyStatus] },
            { no: 5, name: "schedule_relationship", kind: "enum", opt: true, T: () => ["transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship", TripUpdate_StopTimeUpdate_ScheduleRelationship] },
            { no: 6, name: "stop_time_properties", kind: "message", T: () => TripUpdate_StopTimeUpdate_StopTimeProperties }
        ]);
    }
    create(value?: PartialMessage<TripUpdate_StopTimeUpdate>): TripUpdate_StopTimeUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TripUpdate_StopTimeUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripUpdate_StopTimeUpdate): TripUpdate_StopTimeUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stop_sequence */ 1:
                    message.stopSequence = reader.uint32();
                    break;
                case /* optional string stop_id */ 4:
                    message.stopId = reader.string();
                    break;
                case /* optional transit_realtime.TripUpdate.StopTimeEvent arrival */ 2:
                    message.arrival = TripUpdate_StopTimeEvent.internalBinaryRead(reader, reader.uint32(), options, message.arrival);
                    break;
                case /* optional transit_realtime.TripUpdate.StopTimeEvent departure */ 3:
                    message.departure = TripUpdate_StopTimeEvent.internalBinaryRead(reader, reader.uint32(), options, message.departure);
                    break;
                case /* optional transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status */ 7:
                    message.departureOccupancyStatus = reader.int32();
                    break;
                case /* optional transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship */ 5:
                    message.scheduleRelationship = reader.int32();
                    break;
                case /* optional transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties */ 6:
                    message.stopTimeProperties = TripUpdate_StopTimeUpdate_StopTimeProperties.internalBinaryRead(reader, reader.uint32(), options, message.stopTimeProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripUpdate_StopTimeUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stop_sequence = 1; */
        if (message.stopSequence !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.stopSequence);
        /* optional string stop_id = 4; */
        if (message.stopId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.stopId);
        /* optional transit_realtime.TripUpdate.StopTimeEvent arrival = 2; */
        if (message.arrival)
            TripUpdate_StopTimeEvent.internalBinaryWrite(message.arrival, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TripUpdate.StopTimeEvent departure = 3; */
        if (message.departure)
            TripUpdate_StopTimeEvent.internalBinaryWrite(message.departure, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7; */
        if (message.departureOccupancyStatus !== undefined)
            writer.tag(7, WireType.Varint).int32(message.departureOccupancyStatus);
        /* optional transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5; */
        if (message.scheduleRelationship !== undefined)
            writer.tag(5, WireType.Varint).int32(message.scheduleRelationship);
        /* optional transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6; */
        if (message.stopTimeProperties)
            TripUpdate_StopTimeUpdate_StopTimeProperties.internalBinaryWrite(message.stopTimeProperties, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripUpdate.StopTimeUpdate
 */
export const TripUpdate_StopTimeUpdate = new TripUpdate_StopTimeUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripUpdate_StopTimeUpdate_StopTimeProperties$Type extends MessageType<TripUpdate_StopTimeUpdate_StopTimeProperties> {
    constructor() {
        super("transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties", [
            { no: 1, name: "assigned_stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TripUpdate_StopTimeUpdate_StopTimeProperties>): TripUpdate_StopTimeUpdate_StopTimeProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TripUpdate_StopTimeUpdate_StopTimeProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripUpdate_StopTimeUpdate_StopTimeProperties): TripUpdate_StopTimeUpdate_StopTimeProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string assigned_stop_id */ 1:
                    message.assignedStopId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripUpdate_StopTimeUpdate_StopTimeProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string assigned_stop_id = 1; */
        if (message.assignedStopId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.assignedStopId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties
 */
export const TripUpdate_StopTimeUpdate_StopTimeProperties = new TripUpdate_StopTimeUpdate_StopTimeProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripUpdate_TripProperties$Type extends MessageType<TripUpdate_TripProperties> {
    constructor() {
        super("transit_realtime.TripUpdate.TripProperties", [
            { no: 1, name: "trip_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "start_date", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "shape_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TripUpdate_TripProperties>): TripUpdate_TripProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TripUpdate_TripProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripUpdate_TripProperties): TripUpdate_TripProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string trip_id */ 1:
                    message.tripId = reader.string();
                    break;
                case /* optional string start_date */ 2:
                    message.startDate = reader.string();
                    break;
                case /* optional string start_time */ 3:
                    message.startTime = reader.string();
                    break;
                case /* optional string shape_id */ 4:
                    message.shapeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripUpdate_TripProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string trip_id = 1; */
        if (message.tripId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tripId);
        /* optional string start_date = 2; */
        if (message.startDate !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.startDate);
        /* optional string start_time = 3; */
        if (message.startTime !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.startTime);
        /* optional string shape_id = 4; */
        if (message.shapeId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.shapeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripUpdate.TripProperties
 */
export const TripUpdate_TripProperties = new TripUpdate_TripProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehiclePosition$Type extends MessageType<VehiclePosition> {
    constructor() {
        super("transit_realtime.VehiclePosition", [
            { no: 1, name: "trip", kind: "message", T: () => TripDescriptor },
            { no: 8, name: "vehicle", kind: "message", T: () => VehicleDescriptor },
            { no: 2, name: "position", kind: "message", T: () => Position },
            { no: 3, name: "current_stop_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "current_status", kind: "enum", opt: true, T: () => ["transit_realtime.VehiclePosition.VehicleStopStatus", VehiclePosition_VehicleStopStatus] },
            { no: 5, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "congestion_level", kind: "enum", opt: true, T: () => ["transit_realtime.VehiclePosition.CongestionLevel", VehiclePosition_CongestionLevel] },
            { no: 9, name: "occupancy_status", kind: "enum", opt: true, T: () => ["transit_realtime.VehiclePosition.OccupancyStatus", VehiclePosition_OccupancyStatus] },
            { no: 10, name: "occupancy_percentage", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "multi_carriage_details", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => VehiclePosition_CarriageDetails }
        ]);
    }
    create(value?: PartialMessage<VehiclePosition>): VehiclePosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.multiCarriageDetails = [];
        if (value !== undefined)
            reflectionMergePartial<VehiclePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehiclePosition): VehiclePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional transit_realtime.TripDescriptor trip */ 1:
                    message.trip = TripDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.trip);
                    break;
                case /* optional transit_realtime.VehicleDescriptor vehicle */ 8:
                    message.vehicle = VehicleDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.vehicle);
                    break;
                case /* optional transit_realtime.Position position */ 2:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional uint32 current_stop_sequence */ 3:
                    message.currentStopSequence = reader.uint32();
                    break;
                case /* optional string stop_id */ 7:
                    message.stopId = reader.string();
                    break;
                case /* optional transit_realtime.VehiclePosition.VehicleStopStatus current_status */ 4:
                    message.currentStatus = reader.int32();
                    break;
                case /* optional uint64 timestamp */ 5:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional transit_realtime.VehiclePosition.CongestionLevel congestion_level */ 6:
                    message.congestionLevel = reader.int32();
                    break;
                case /* optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status */ 9:
                    message.occupancyStatus = reader.int32();
                    break;
                case /* optional uint32 occupancy_percentage */ 10:
                    message.occupancyPercentage = reader.uint32();
                    break;
                case /* repeated transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details */ 11:
                    message.multiCarriageDetails.push(VehiclePosition_CarriageDetails.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehiclePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional transit_realtime.TripDescriptor trip = 1; */
        if (message.trip)
            TripDescriptor.internalBinaryWrite(message.trip, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.VehicleDescriptor vehicle = 8; */
        if (message.vehicle)
            VehicleDescriptor.internalBinaryWrite(message.vehicle, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Position position = 2; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 current_stop_sequence = 3; */
        if (message.currentStopSequence !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.currentStopSequence);
        /* optional string stop_id = 7; */
        if (message.stopId !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.stopId);
        /* optional transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4; */
        if (message.currentStatus !== undefined)
            writer.tag(4, WireType.Varint).int32(message.currentStatus);
        /* optional uint64 timestamp = 5; */
        if (message.timestamp !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.timestamp);
        /* optional transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6; */
        if (message.congestionLevel !== undefined)
            writer.tag(6, WireType.Varint).int32(message.congestionLevel);
        /* optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9; */
        if (message.occupancyStatus !== undefined)
            writer.tag(9, WireType.Varint).int32(message.occupancyStatus);
        /* optional uint32 occupancy_percentage = 10; */
        if (message.occupancyPercentage !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.occupancyPercentage);
        /* repeated transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11; */
        for (let i = 0; i < message.multiCarriageDetails.length; i++)
            VehiclePosition_CarriageDetails.internalBinaryWrite(message.multiCarriageDetails[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.VehiclePosition
 */
export const VehiclePosition = new VehiclePosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehiclePosition_CarriageDetails$Type extends MessageType<VehiclePosition_CarriageDetails> {
    constructor() {
        super("transit_realtime.VehiclePosition.CarriageDetails", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "occupancy_status", kind: "enum", opt: true, T: () => ["transit_realtime.VehiclePosition.OccupancyStatus", VehiclePosition_OccupancyStatus] },
            { no: 4, name: "occupancy_percentage", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "carriage_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<VehiclePosition_CarriageDetails>): VehiclePosition_CarriageDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VehiclePosition_CarriageDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehiclePosition_CarriageDetails): VehiclePosition_CarriageDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string label */ 2:
                    message.label = reader.string();
                    break;
                case /* optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status */ 3:
                    message.occupancyStatus = reader.int32();
                    break;
                case /* optional int32 occupancy_percentage */ 4:
                    message.occupancyPercentage = reader.int32();
                    break;
                case /* optional uint32 carriage_sequence */ 5:
                    message.carriageSequence = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehiclePosition_CarriageDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string label = 2; */
        if (message.label !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3; */
        if (message.occupancyStatus !== undefined)
            writer.tag(3, WireType.Varint).int32(message.occupancyStatus);
        /* optional int32 occupancy_percentage = 4; */
        if (message.occupancyPercentage !== undefined)
            writer.tag(4, WireType.Varint).int32(message.occupancyPercentage);
        /* optional uint32 carriage_sequence = 5; */
        if (message.carriageSequence !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.carriageSequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.VehiclePosition.CarriageDetails
 */
export const VehiclePosition_CarriageDetails = new VehiclePosition_CarriageDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Alert$Type extends MessageType<Alert> {
    constructor() {
        super("transit_realtime.Alert", [
            { no: 1, name: "active_period", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TimeRange },
            { no: 5, name: "informed_entity", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EntitySelector },
            { no: 6, name: "cause", kind: "enum", opt: true, T: () => ["transit_realtime.Alert.Cause", Alert_Cause] },
            { no: 7, name: "effect", kind: "enum", opt: true, T: () => ["transit_realtime.Alert.Effect", Alert_Effect] },
            { no: 8, name: "url", kind: "message", T: () => TranslatedString },
            { no: 10, name: "header_text", kind: "message", T: () => TranslatedString },
            { no: 11, name: "description_text", kind: "message", T: () => TranslatedString },
            { no: 12, name: "tts_header_text", kind: "message", T: () => TranslatedString },
            { no: 13, name: "tts_description_text", kind: "message", T: () => TranslatedString },
            { no: 14, name: "severity_level", kind: "enum", opt: true, T: () => ["transit_realtime.Alert.SeverityLevel", Alert_SeverityLevel] },
            { no: 15, name: "image", kind: "message", T: () => TranslatedImage },
            { no: 16, name: "image_alternative_text", kind: "message", T: () => TranslatedString },
            { no: 17, name: "cause_detail", kind: "message", T: () => TranslatedString },
            { no: 18, name: "effect_detail", kind: "message", T: () => TranslatedString }
        ]);
    }
    create(value?: PartialMessage<Alert>): Alert {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activePeriod = [];
        message.informedEntity = [];
        if (value !== undefined)
            reflectionMergePartial<Alert>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Alert): Alert {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated transit_realtime.TimeRange active_period */ 1:
                    message.activePeriod.push(TimeRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated transit_realtime.EntitySelector informed_entity */ 5:
                    message.informedEntity.push(EntitySelector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional transit_realtime.Alert.Cause cause */ 6:
                    message.cause = reader.int32();
                    break;
                case /* optional transit_realtime.Alert.Effect effect */ 7:
                    message.effect = reader.int32();
                    break;
                case /* optional transit_realtime.TranslatedString url */ 8:
                    message.url = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.url);
                    break;
                case /* optional transit_realtime.TranslatedString header_text */ 10:
                    message.headerText = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.headerText);
                    break;
                case /* optional transit_realtime.TranslatedString description_text */ 11:
                    message.descriptionText = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.descriptionText);
                    break;
                case /* optional transit_realtime.TranslatedString tts_header_text */ 12:
                    message.ttsHeaderText = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.ttsHeaderText);
                    break;
                case /* optional transit_realtime.TranslatedString tts_description_text */ 13:
                    message.ttsDescriptionText = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.ttsDescriptionText);
                    break;
                case /* optional transit_realtime.Alert.SeverityLevel severity_level */ 14:
                    message.severityLevel = reader.int32();
                    break;
                case /* optional transit_realtime.TranslatedImage image */ 15:
                    message.image = TranslatedImage.internalBinaryRead(reader, reader.uint32(), options, message.image);
                    break;
                case /* optional transit_realtime.TranslatedString image_alternative_text */ 16:
                    message.imageAlternativeText = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.imageAlternativeText);
                    break;
                case /* optional transit_realtime.TranslatedString cause_detail */ 17:
                    message.causeDetail = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.causeDetail);
                    break;
                case /* optional transit_realtime.TranslatedString effect_detail */ 18:
                    message.effectDetail = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.effectDetail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Alert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated transit_realtime.TimeRange active_period = 1; */
        for (let i = 0; i < message.activePeriod.length; i++)
            TimeRange.internalBinaryWrite(message.activePeriod[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated transit_realtime.EntitySelector informed_entity = 5; */
        for (let i = 0; i < message.informedEntity.length; i++)
            EntitySelector.internalBinaryWrite(message.informedEntity[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Alert.Cause cause = 6; */
        if (message.cause !== undefined)
            writer.tag(6, WireType.Varint).int32(message.cause);
        /* optional transit_realtime.Alert.Effect effect = 7; */
        if (message.effect !== undefined)
            writer.tag(7, WireType.Varint).int32(message.effect);
        /* optional transit_realtime.TranslatedString url = 8; */
        if (message.url)
            TranslatedString.internalBinaryWrite(message.url, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString header_text = 10; */
        if (message.headerText)
            TranslatedString.internalBinaryWrite(message.headerText, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString description_text = 11; */
        if (message.descriptionText)
            TranslatedString.internalBinaryWrite(message.descriptionText, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString tts_header_text = 12; */
        if (message.ttsHeaderText)
            TranslatedString.internalBinaryWrite(message.ttsHeaderText, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString tts_description_text = 13; */
        if (message.ttsDescriptionText)
            TranslatedString.internalBinaryWrite(message.ttsDescriptionText, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.Alert.SeverityLevel severity_level = 14; */
        if (message.severityLevel !== undefined)
            writer.tag(14, WireType.Varint).int32(message.severityLevel);
        /* optional transit_realtime.TranslatedImage image = 15; */
        if (message.image)
            TranslatedImage.internalBinaryWrite(message.image, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString image_alternative_text = 16; */
        if (message.imageAlternativeText)
            TranslatedString.internalBinaryWrite(message.imageAlternativeText, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString cause_detail = 17; */
        if (message.causeDetail)
            TranslatedString.internalBinaryWrite(message.causeDetail, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString effect_detail = 18; */
        if (message.effectDetail)
            TranslatedString.internalBinaryWrite(message.effectDetail, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.Alert
 */
export const Alert = new Alert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeRange$Type extends MessageType<TimeRange> {
    constructor() {
        super("transit_realtime.TimeRange", [
            { no: 1, name: "start", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "end", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TimeRange>): TimeRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TimeRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeRange): TimeRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 start */ 1:
                    message.start = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 end */ 2:
                    message.end = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 start = 1; */
        if (message.start !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.start);
        /* optional uint64 end = 2; */
        if (message.end !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.end);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TimeRange
 */
export const TimeRange = new TimeRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("transit_realtime.Position", [
            { no: 1, name: "latitude", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "longitude", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "bearing", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "odometer", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitude = 0;
        message.longitude = 0;
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float latitude */ 1:
                    message.latitude = reader.float();
                    break;
                case /* float longitude */ 2:
                    message.longitude = reader.float();
                    break;
                case /* optional float bearing */ 3:
                    message.bearing = reader.float();
                    break;
                case /* optional double odometer */ 4:
                    message.odometer = reader.double();
                    break;
                case /* optional float speed */ 5:
                    message.speed = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float latitude = 1; */
        if (message.latitude !== 0)
            writer.tag(1, WireType.Bit32).float(message.latitude);
        /* float longitude = 2; */
        if (message.longitude !== 0)
            writer.tag(2, WireType.Bit32).float(message.longitude);
        /* optional float bearing = 3; */
        if (message.bearing !== undefined)
            writer.tag(3, WireType.Bit32).float(message.bearing);
        /* optional double odometer = 4; */
        if (message.odometer !== undefined)
            writer.tag(4, WireType.Bit64).double(message.odometer);
        /* optional float speed = 5; */
        if (message.speed !== undefined)
            writer.tag(5, WireType.Bit32).float(message.speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripDescriptor$Type extends MessageType<TripDescriptor> {
    constructor() {
        super("transit_realtime.TripDescriptor", [
            { no: 1, name: "trip_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "route_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "direction_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_date", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "schedule_relationship", kind: "enum", opt: true, T: () => ["transit_realtime.TripDescriptor.ScheduleRelationship", TripDescriptor_ScheduleRelationship] },
            { no: 7, name: "modified_trip", kind: "message", T: () => TripDescriptor_ModifiedTripSelector }
        ]);
    }
    create(value?: PartialMessage<TripDescriptor>): TripDescriptor {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TripDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripDescriptor): TripDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string trip_id */ 1:
                    message.tripId = reader.string();
                    break;
                case /* optional string route_id */ 5:
                    message.routeId = reader.string();
                    break;
                case /* optional uint32 direction_id */ 6:
                    message.directionId = reader.uint32();
                    break;
                case /* optional string start_time */ 2:
                    message.startTime = reader.string();
                    break;
                case /* optional string start_date */ 3:
                    message.startDate = reader.string();
                    break;
                case /* optional transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship */ 4:
                    message.scheduleRelationship = reader.int32();
                    break;
                case /* optional transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip */ 7:
                    message.modifiedTrip = TripDescriptor_ModifiedTripSelector.internalBinaryRead(reader, reader.uint32(), options, message.modifiedTrip);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string trip_id = 1; */
        if (message.tripId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tripId);
        /* optional string route_id = 5; */
        if (message.routeId !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.routeId);
        /* optional uint32 direction_id = 6; */
        if (message.directionId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.directionId);
        /* optional string start_time = 2; */
        if (message.startTime !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.startTime);
        /* optional string start_date = 3; */
        if (message.startDate !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.startDate);
        /* optional transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4; */
        if (message.scheduleRelationship !== undefined)
            writer.tag(4, WireType.Varint).int32(message.scheduleRelationship);
        /* optional transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7; */
        if (message.modifiedTrip)
            TripDescriptor_ModifiedTripSelector.internalBinaryWrite(message.modifiedTrip, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripDescriptor
 */
export const TripDescriptor = new TripDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripDescriptor_ModifiedTripSelector$Type extends MessageType<TripDescriptor_ModifiedTripSelector> {
    constructor() {
        super("transit_realtime.TripDescriptor.ModifiedTripSelector", [
            { no: 1, name: "modifications_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "affected_trip_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start_time", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "start_date", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TripDescriptor_ModifiedTripSelector>): TripDescriptor_ModifiedTripSelector {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TripDescriptor_ModifiedTripSelector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripDescriptor_ModifiedTripSelector): TripDescriptor_ModifiedTripSelector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string modifications_id */ 1:
                    message.modificationsId = reader.string();
                    break;
                case /* optional string affected_trip_id */ 2:
                    message.affectedTripId = reader.string();
                    break;
                case /* optional string start_time */ 3:
                    message.startTime = reader.string();
                    break;
                case /* optional string start_date */ 4:
                    message.startDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripDescriptor_ModifiedTripSelector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string modifications_id = 1; */
        if (message.modificationsId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.modificationsId);
        /* optional string affected_trip_id = 2; */
        if (message.affectedTripId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.affectedTripId);
        /* optional string start_time = 3; */
        if (message.startTime !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.startTime);
        /* optional string start_date = 4; */
        if (message.startDate !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.startDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripDescriptor.ModifiedTripSelector
 */
export const TripDescriptor_ModifiedTripSelector = new TripDescriptor_ModifiedTripSelector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleDescriptor$Type extends MessageType<VehicleDescriptor> {
    constructor() {
        super("transit_realtime.VehicleDescriptor", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "license_plate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "wheelchair_accessible", kind: "enum", opt: true, T: () => ["transit_realtime.VehicleDescriptor.WheelchairAccessible", VehicleDescriptor_WheelchairAccessible] }
        ]);
    }
    create(value?: PartialMessage<VehicleDescriptor>): VehicleDescriptor {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VehicleDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleDescriptor): VehicleDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string label */ 2:
                    message.label = reader.string();
                    break;
                case /* optional string license_plate */ 3:
                    message.licensePlate = reader.string();
                    break;
                case /* optional transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible */ 4:
                    message.wheelchairAccessible = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string label = 2; */
        if (message.label !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* optional string license_plate = 3; */
        if (message.licensePlate !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.licensePlate);
        /* optional transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4; */
        if (message.wheelchairAccessible !== undefined)
            writer.tag(4, WireType.Varint).int32(message.wheelchairAccessible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.VehicleDescriptor
 */
export const VehicleDescriptor = new VehicleDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntitySelector$Type extends MessageType<EntitySelector> {
    constructor() {
        super("transit_realtime.EntitySelector", [
            { no: 1, name: "agency_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "route_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "route_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "trip", kind: "message", T: () => TripDescriptor },
            { no: 5, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "direction_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EntitySelector>): EntitySelector {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EntitySelector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntitySelector): EntitySelector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string agency_id */ 1:
                    message.agencyId = reader.string();
                    break;
                case /* optional string route_id */ 2:
                    message.routeId = reader.string();
                    break;
                case /* optional int32 route_type */ 3:
                    message.routeType = reader.int32();
                    break;
                case /* optional transit_realtime.TripDescriptor trip */ 4:
                    message.trip = TripDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.trip);
                    break;
                case /* optional string stop_id */ 5:
                    message.stopId = reader.string();
                    break;
                case /* optional uint32 direction_id */ 6:
                    message.directionId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntitySelector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string agency_id = 1; */
        if (message.agencyId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.agencyId);
        /* optional string route_id = 2; */
        if (message.routeId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.routeId);
        /* optional int32 route_type = 3; */
        if (message.routeType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.routeType);
        /* optional transit_realtime.TripDescriptor trip = 4; */
        if (message.trip)
            TripDescriptor.internalBinaryWrite(message.trip, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string stop_id = 5; */
        if (message.stopId !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.stopId);
        /* optional uint32 direction_id = 6; */
        if (message.directionId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.directionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.EntitySelector
 */
export const EntitySelector = new EntitySelector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslatedString$Type extends MessageType<TranslatedString> {
    constructor() {
        super("transit_realtime.TranslatedString", [
            { no: 1, name: "translation", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TranslatedString_Translation }
        ]);
    }
    create(value?: PartialMessage<TranslatedString>): TranslatedString {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.translation = [];
        if (value !== undefined)
            reflectionMergePartial<TranslatedString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslatedString): TranslatedString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated transit_realtime.TranslatedString.Translation translation */ 1:
                    message.translation.push(TranslatedString_Translation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslatedString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated transit_realtime.TranslatedString.Translation translation = 1; */
        for (let i = 0; i < message.translation.length; i++)
            TranslatedString_Translation.internalBinaryWrite(message.translation[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TranslatedString
 */
export const TranslatedString = new TranslatedString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslatedString_Translation$Type extends MessageType<TranslatedString_Translation> {
    constructor() {
        super("transit_realtime.TranslatedString.Translation", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TranslatedString_Translation>): TranslatedString_Translation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<TranslatedString_Translation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslatedString_Translation): TranslatedString_Translation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* optional string language */ 2:
                    message.language = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslatedString_Translation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* optional string language = 2; */
        if (message.language !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.language);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TranslatedString.Translation
 */
export const TranslatedString_Translation = new TranslatedString_Translation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslatedImage$Type extends MessageType<TranslatedImage> {
    constructor() {
        super("transit_realtime.TranslatedImage", [
            { no: 1, name: "localized_image", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TranslatedImage_LocalizedImage }
        ]);
    }
    create(value?: PartialMessage<TranslatedImage>): TranslatedImage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localizedImage = [];
        if (value !== undefined)
            reflectionMergePartial<TranslatedImage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslatedImage): TranslatedImage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated transit_realtime.TranslatedImage.LocalizedImage localized_image */ 1:
                    message.localizedImage.push(TranslatedImage_LocalizedImage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslatedImage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated transit_realtime.TranslatedImage.LocalizedImage localized_image = 1; */
        for (let i = 0; i < message.localizedImage.length; i++)
            TranslatedImage_LocalizedImage.internalBinaryWrite(message.localizedImage[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TranslatedImage
 */
export const TranslatedImage = new TranslatedImage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslatedImage_LocalizedImage$Type extends MessageType<TranslatedImage_LocalizedImage> {
    constructor() {
        super("transit_realtime.TranslatedImage.LocalizedImage", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "media_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TranslatedImage_LocalizedImage>): TranslatedImage_LocalizedImage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.mediaType = "";
        if (value !== undefined)
            reflectionMergePartial<TranslatedImage_LocalizedImage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslatedImage_LocalizedImage): TranslatedImage_LocalizedImage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string media_type */ 2:
                    message.mediaType = reader.string();
                    break;
                case /* optional string language */ 3:
                    message.language = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslatedImage_LocalizedImage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string media_type = 2; */
        if (message.mediaType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mediaType);
        /* optional string language = 3; */
        if (message.language !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.language);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TranslatedImage.LocalizedImage
 */
export const TranslatedImage_LocalizedImage = new TranslatedImage_LocalizedImage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shape$Type extends MessageType<Shape> {
    constructor() {
        super("transit_realtime.Shape", [
            { no: 1, name: "shape_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "encoded_polyline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Shape>): Shape {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Shape>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shape): Shape {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string shape_id */ 1:
                    message.shapeId = reader.string();
                    break;
                case /* optional string encoded_polyline */ 2:
                    message.encodedPolyline = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Shape, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string shape_id = 1; */
        if (message.shapeId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.shapeId);
        /* optional string encoded_polyline = 2; */
        if (message.encodedPolyline !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.encodedPolyline);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.Shape
 */
export const Shape = new Shape$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stop$Type extends MessageType<Stop> {
    constructor() {
        super("transit_realtime.Stop", [
            { no: 1, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "stop_code", kind: "message", T: () => TranslatedString },
            { no: 3, name: "stop_name", kind: "message", T: () => TranslatedString },
            { no: 4, name: "tts_stop_name", kind: "message", T: () => TranslatedString },
            { no: 5, name: "stop_desc", kind: "message", T: () => TranslatedString },
            { no: 6, name: "stop_lat", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "stop_lon", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "zone_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "stop_url", kind: "message", T: () => TranslatedString },
            { no: 11, name: "parent_station", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "stop_timezone", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "wheelchair_boarding", kind: "enum", opt: true, T: () => ["transit_realtime.Stop.WheelchairBoarding", Stop_WheelchairBoarding] },
            { no: 14, name: "level_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "platform_code", kind: "message", T: () => TranslatedString }
        ]);
    }
    create(value?: PartialMessage<Stop>): Stop {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Stop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stop): Stop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string stop_id */ 1:
                    message.stopId = reader.string();
                    break;
                case /* optional transit_realtime.TranslatedString stop_code */ 2:
                    message.stopCode = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.stopCode);
                    break;
                case /* optional transit_realtime.TranslatedString stop_name */ 3:
                    message.stopName = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.stopName);
                    break;
                case /* optional transit_realtime.TranslatedString tts_stop_name */ 4:
                    message.ttsStopName = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.ttsStopName);
                    break;
                case /* optional transit_realtime.TranslatedString stop_desc */ 5:
                    message.stopDesc = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.stopDesc);
                    break;
                case /* optional float stop_lat */ 6:
                    message.stopLat = reader.float();
                    break;
                case /* optional float stop_lon */ 7:
                    message.stopLon = reader.float();
                    break;
                case /* optional string zone_id */ 8:
                    message.zoneId = reader.string();
                    break;
                case /* optional transit_realtime.TranslatedString stop_url */ 9:
                    message.stopUrl = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.stopUrl);
                    break;
                case /* optional string parent_station */ 11:
                    message.parentStation = reader.string();
                    break;
                case /* optional string stop_timezone */ 12:
                    message.stopTimezone = reader.string();
                    break;
                case /* optional transit_realtime.Stop.WheelchairBoarding wheelchair_boarding */ 13:
                    message.wheelchairBoarding = reader.int32();
                    break;
                case /* optional string level_id */ 14:
                    message.levelId = reader.string();
                    break;
                case /* optional transit_realtime.TranslatedString platform_code */ 15:
                    message.platformCode = TranslatedString.internalBinaryRead(reader, reader.uint32(), options, message.platformCode);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string stop_id = 1; */
        if (message.stopId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.stopId);
        /* optional transit_realtime.TranslatedString stop_code = 2; */
        if (message.stopCode)
            TranslatedString.internalBinaryWrite(message.stopCode, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString stop_name = 3; */
        if (message.stopName)
            TranslatedString.internalBinaryWrite(message.stopName, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString tts_stop_name = 4; */
        if (message.ttsStopName)
            TranslatedString.internalBinaryWrite(message.ttsStopName, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.TranslatedString stop_desc = 5; */
        if (message.stopDesc)
            TranslatedString.internalBinaryWrite(message.stopDesc, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional float stop_lat = 6; */
        if (message.stopLat !== undefined)
            writer.tag(6, WireType.Bit32).float(message.stopLat);
        /* optional float stop_lon = 7; */
        if (message.stopLon !== undefined)
            writer.tag(7, WireType.Bit32).float(message.stopLon);
        /* optional string zone_id = 8; */
        if (message.zoneId !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.zoneId);
        /* optional transit_realtime.TranslatedString stop_url = 9; */
        if (message.stopUrl)
            TranslatedString.internalBinaryWrite(message.stopUrl, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional string parent_station = 11; */
        if (message.parentStation !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.parentStation);
        /* optional string stop_timezone = 12; */
        if (message.stopTimezone !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.stopTimezone);
        /* optional transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13; */
        if (message.wheelchairBoarding !== undefined)
            writer.tag(13, WireType.Varint).int32(message.wheelchairBoarding);
        /* optional string level_id = 14; */
        if (message.levelId !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.levelId);
        /* optional transit_realtime.TranslatedString platform_code = 15; */
        if (message.platformCode)
            TranslatedString.internalBinaryWrite(message.platformCode, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.Stop
 */
export const Stop = new Stop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripModifications$Type extends MessageType<TripModifications> {
    constructor() {
        super("transit_realtime.TripModifications", [
            { no: 1, name: "selected_trips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TripModifications_SelectedTrips },
            { no: 2, name: "start_times", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "service_dates", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "modifications", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TripModifications_Modification }
        ]);
    }
    create(value?: PartialMessage<TripModifications>): TripModifications {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.selectedTrips = [];
        message.startTimes = [];
        message.serviceDates = [];
        message.modifications = [];
        if (value !== undefined)
            reflectionMergePartial<TripModifications>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripModifications): TripModifications {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated transit_realtime.TripModifications.SelectedTrips selected_trips */ 1:
                    message.selectedTrips.push(TripModifications_SelectedTrips.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string start_times */ 2:
                    message.startTimes.push(reader.string());
                    break;
                case /* repeated string service_dates */ 3:
                    message.serviceDates.push(reader.string());
                    break;
                case /* repeated transit_realtime.TripModifications.Modification modifications */ 4:
                    message.modifications.push(TripModifications_Modification.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripModifications, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated transit_realtime.TripModifications.SelectedTrips selected_trips = 1; */
        for (let i = 0; i < message.selectedTrips.length; i++)
            TripModifications_SelectedTrips.internalBinaryWrite(message.selectedTrips[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string start_times = 2; */
        for (let i = 0; i < message.startTimes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.startTimes[i]);
        /* repeated string service_dates = 3; */
        for (let i = 0; i < message.serviceDates.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.serviceDates[i]);
        /* repeated transit_realtime.TripModifications.Modification modifications = 4; */
        for (let i = 0; i < message.modifications.length; i++)
            TripModifications_Modification.internalBinaryWrite(message.modifications[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripModifications
 */
export const TripModifications = new TripModifications$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripModifications_Modification$Type extends MessageType<TripModifications_Modification> {
    constructor() {
        super("transit_realtime.TripModifications.Modification", [
            { no: 1, name: "start_stop_selector", kind: "message", T: () => StopSelector },
            { no: 2, name: "end_stop_selector", kind: "message", T: () => StopSelector },
            { no: 3, name: "propagated_modification_delay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "replacement_stops", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ReplacementStop },
            { no: 5, name: "service_alert_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "last_modified_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TripModifications_Modification>): TripModifications_Modification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.replacementStops = [];
        if (value !== undefined)
            reflectionMergePartial<TripModifications_Modification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripModifications_Modification): TripModifications_Modification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional transit_realtime.StopSelector start_stop_selector */ 1:
                    message.startStopSelector = StopSelector.internalBinaryRead(reader, reader.uint32(), options, message.startStopSelector);
                    break;
                case /* optional transit_realtime.StopSelector end_stop_selector */ 2:
                    message.endStopSelector = StopSelector.internalBinaryRead(reader, reader.uint32(), options, message.endStopSelector);
                    break;
                case /* optional int32 propagated_modification_delay */ 3:
                    message.propagatedModificationDelay = reader.int32();
                    break;
                case /* repeated transit_realtime.ReplacementStop replacement_stops */ 4:
                    message.replacementStops.push(ReplacementStop.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string service_alert_id */ 5:
                    message.serviceAlertId = reader.string();
                    break;
                case /* optional uint64 last_modified_time */ 6:
                    message.lastModifiedTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripModifications_Modification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional transit_realtime.StopSelector start_stop_selector = 1; */
        if (message.startStopSelector)
            StopSelector.internalBinaryWrite(message.startStopSelector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional transit_realtime.StopSelector end_stop_selector = 2; */
        if (message.endStopSelector)
            StopSelector.internalBinaryWrite(message.endStopSelector, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 propagated_modification_delay = 3; */
        if (message.propagatedModificationDelay !== undefined)
            writer.tag(3, WireType.Varint).int32(message.propagatedModificationDelay);
        /* repeated transit_realtime.ReplacementStop replacement_stops = 4; */
        for (let i = 0; i < message.replacementStops.length; i++)
            ReplacementStop.internalBinaryWrite(message.replacementStops[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string service_alert_id = 5; */
        if (message.serviceAlertId !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.serviceAlertId);
        /* optional uint64 last_modified_time = 6; */
        if (message.lastModifiedTime !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.lastModifiedTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripModifications.Modification
 */
export const TripModifications_Modification = new TripModifications_Modification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TripModifications_SelectedTrips$Type extends MessageType<TripModifications_SelectedTrips> {
    constructor() {
        super("transit_realtime.TripModifications.SelectedTrips", [
            { no: 1, name: "trip_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shape_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TripModifications_SelectedTrips>): TripModifications_SelectedTrips {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tripIds = [];
        if (value !== undefined)
            reflectionMergePartial<TripModifications_SelectedTrips>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TripModifications_SelectedTrips): TripModifications_SelectedTrips {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string trip_ids */ 1:
                    message.tripIds.push(reader.string());
                    break;
                case /* optional string shape_id */ 2:
                    message.shapeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TripModifications_SelectedTrips, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string trip_ids = 1; */
        for (let i = 0; i < message.tripIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.tripIds[i]);
        /* optional string shape_id = 2; */
        if (message.shapeId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.shapeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.TripModifications.SelectedTrips
 */
export const TripModifications_SelectedTrips = new TripModifications_SelectedTrips$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopSelector$Type extends MessageType<StopSelector> {
    constructor() {
        super("transit_realtime.StopSelector", [
            { no: 1, name: "stop_sequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StopSelector>): StopSelector {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopSelector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopSelector): StopSelector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stop_sequence */ 1:
                    message.stopSequence = reader.uint32();
                    break;
                case /* optional string stop_id */ 2:
                    message.stopId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopSelector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stop_sequence = 1; */
        if (message.stopSequence !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.stopSequence);
        /* optional string stop_id = 2; */
        if (message.stopId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.stopId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.StopSelector
 */
export const StopSelector = new StopSelector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplacementStop$Type extends MessageType<ReplacementStop> {
    constructor() {
        super("transit_realtime.ReplacementStop", [
            { no: 1, name: "travel_time_to_stop", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "stop_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReplacementStop>): ReplacementStop {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReplacementStop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReplacementStop): ReplacementStop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 travel_time_to_stop */ 1:
                    message.travelTimeToStop = reader.int32();
                    break;
                case /* optional string stop_id */ 2:
                    message.stopId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReplacementStop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 travel_time_to_stop = 1; */
        if (message.travelTimeToStop !== undefined)
            writer.tag(1, WireType.Varint).int32(message.travelTimeToStop);
        /* optional string stop_id = 2; */
        if (message.stopId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.stopId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message transit_realtime.ReplacementStop
 */
export const ReplacementStop = new ReplacementStop$Type();
